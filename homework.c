//Домашняя контрольная работа
//Выполнила Янпольская А.Ю.
//группа 803СА1
//Преподаватель Голкова Наталья Викторовна
//
//
//Задачи на оценку Отлично


//задача номер 1
//
//  Дан целочисленный массив из 30 элементов.
//  Элементы массива могут принимать произвольные целые значения.
//  Напишите программу, которая находит и выводит сумму наибольшей
//  по длине возрастающей последовательности подряд идущих элементов.
//  Если таких последовательностей несколько, можно вывести любую из них.

	#include<stdio.h>
	#include<stdlib.h>
	#include<time.h>
	#include<conio.h>
	#include<locale.h>
	
	#define n 30   //  размер массива                                  
	
	int main()
	{
		srand((unsigned)time(NULL));        // srand чтобы при каждом запуске задавались разные числа
		setlocale(LC_ALL, "rus");           // подключение русского языка   
		int a[n];
		for (int i = 0; i < n; i++)         // по условию задачи массив известен, я решил вместо ввода
		{                                   // элементов задать им рандомные значения из диапозона типа int
			a[i] = rand() % 65535 - 32767;  // включая отрицательные                      
		}                                       
		int k = 1, kmax = 0, s = a[0], smax = 0;
	
		for (int i = 1; i < n; i++)
		{
		
			if (a[i]>a[i-1])             //сравниваем два последующих элемента
			{                            // и если  они идут по возрастанию тогда мы лобавляем 1
				k++;					 // к переменной к(длинна цепочки)
				s = s + a[i+1];          // а так же считаем сумму цепочки
			}
			else                         //если цепочка по возрастанию прерывается 
			{							 // к присваиваем 1 (цепочка 1 элемент точно содержит)
				k = 1;					 // а в s присваиваем первый элемент следующей цепочки
				s = a[i];
			}
			if (k > kmax)				 // если длинна новой цепочки больше максимально 
			{							 // найденной ранее мы заменяем старую на новую
				smax = s;				 // и запоминаем её сумму
				kmax = k;
			}
		}
		printf("Сумма максимальной длинны последовательности %d", smax);  // выводим сумму наибольшей последовательности
		_getch();
		return 0;
	}



//задача номер 2
//
//  Дан целочисленный массив из 31 элемента, в котором записаны значения температуры воздуха в марте.
//  Элементы массива могут принимать значения от(–20)  до 20. Напишите программу, 
//  которая подсчитывает и выводит среднюю температуру по всем дням, когда была оттепель
//  (температура поднималась выше нуля).Гарантируется, что хотя бы один день в марте была оттепель.

#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<conio.h>
#include<locale.h>

#define n 31    //  размер массива                                  


int main()
{
	srand((unsigned)time(NULL));      // srand чтобы при каждом запуске задавались разные числа
	setlocale(LC_ALL, "rus");         // подключение русского языка   
	int a[n];
	for (int i = 0; i < n; i++)       // по условию задачи массив состоит из 31 элемента из диапозона [-20;20]
	{
		a[i] = rand() % 41 - 20;      // случайно задается массив из диапозона
	}
	int k = 0, s = 0;                 // к - количество подходящих значений   s - сумма подходящих значений
	for (int i = 0; i < n; i++)       // проходим по массиву и проверяем
	{								  // если элемент массива (температура) больше 0 (оттепель)					
		if (a[i] > 0)				  // добавляем к k 1 и считаем сумму подходящих температур
		{
			k++;
			s = s + a[i];
		}
	}
	double average = (double)s / (double)k;  // считаем среднее значение (сумму элементов делим на их количество)
	printf("Средняя температура оттепели %f", average);  // Берем тип double для более точного среднего (с дробной частью)
	_getch();                                            // чтобы правильно выводилось в подсчете указываем что s и k  должны делиться и выдавать дробную часть
	return 0;
}



//	Задача номер 3
//
//  Дано число  М  и две последовательности чисел А(0), А(1), А(2), ...   А(М - 1)
//  и  В(0), В(1), В(2), ..., В(М - 1).Образовать последовательность  чисел С,
//  состоящих из элементов последовательности А, которых нет в последовательности В.

#define _CRT_SECURE_NO_WARNINGS // для исправления ошибки со scanf_s

#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<conio.h>
#include<locale.h>

int main()
{
	srand((unsigned)time(NULL));
	setlocale(LC_ALL, "rus");
	int m, *a, *b, *c, s, k=0;   // задаем переменные и указатели массивов
	printf("Введите число m");
	scanf("%d", &m);             // вводим следующее после размера массивов (последовательностей) число
	a = (int *)malloc(m - 1 * sizeof(int));   // выделяем память под  массивы для хранения 
	b = (int *)malloc(m - 1 * sizeof(int));   // меняющегося размера массивов
	for (int i = 0; i < m - 1; i++)
	{
		a[i] = rand() % 65535 - 32767;        // по условию задачи массив известен, я решил вместо ввода
		b[i] = rand() % 65535 - 32767;        // элементов задать им рандомные значения из диапозона типа int
	}                                         // включая отрицательные
	c = (int *)malloc(m - 1 * sizeof(int));   // выделяем память под  массив
	for (int i = 0; i < m - 1; i++)           // проходим по массиву A
	{
		s = 1;                                // переменная s в данном случае как рычаг
		for (int j = 0; j < m - 1; j++)       // проходим по массиву B
		{
			if (a[i] == b[j])                 // сравниваем элементы массивов (поочередно каждый элемент A со всеми элементами B)
			{								  // и если какие-то элементы есть и там и там мы ставим переключатель в положение 0
				s = 0;                        // и берем другой элемент с выключателем в положении 1
			}
		}
		if (s != 0)                           // если выключатель на каком-то элементе не равен 0 
		{									  // то мы заносим этот элемент в массив C
			c[k] = a[i];
			k++;							  // переменная k увеличивается каждый раз переключаясь на следующий элемент C
		}
	}
	printf("c=  ");
	for (int i = 0; i < m - 1; i++)
	{
		printf(" %d ", a[i]);
	}
	printf("\n");
	printf("c=  ");
	for (int i = 0; i < m - 1; i++)      // Выводим все три массива чтобы можно было проверить правильность работы программы
	{
		printf(" %d ", b[i]);
	}
	printf("\n");
	printf("c=  ");
	for (int i = 0; i < m - 1; i++)
	{
		
		printf(" %d ", c[i]);
	}
  free(a);
  free(b);                           // освобождаем выделденную память под массивы
  free(c);
	_getch();
	return 0;
}



//задача номер 4
//
//  Дано натуральное число  N , последовательность натуральных чисел  a1, ... , aN
//  и два различных натуральных числа  c1  и  c2. Последовательность чисел упорядочена по убыванию,
//  a1 > a2 > ... > aN. Напишите программу, вставляющую числа  c1  и  c2  в последовательность так,
//  чтобы сохранилась ее упорядоченность.

#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<conio.h>
#include<locale.h>

int main()
{
	srand((unsigned)time(NULL));
	setlocale(LC_ALL, "rus");
	int n, *a, c1, c2, ic;
	printf("Введите число N\n");
	scanf("%d", &n);
	printf("Введите число C1\n");            // вводим переменные
	scanf("%d", &c1);
	printf("Введите число C2\n");
	scanf("%d", &c2);
	a = (int *)malloc(n * sizeof(int));      // выделяем память под массив
	for (int i = 0; i < n; i++)              // заполняем массив
	{
		a[i] = rand() % 10 + 1;
	}
	for (int i = 0; i < n; i++)              // т.к массив по условию упорядочен
	{                                        // я отсортировал его
		for (int j = i + 1; j < n; j++)
		{
			if (a[i] < a[j])
			{
				int temp = a[i];
				a[i] = a[j];
				a[j] = temp;
			}
		}
	}
	a = (int*)realloc(a, (n + 1) * sizeof(int));  // увеличиваем место выделенное под массив
	for (int i = 1; i < n; i++)                   // в цикле проходим по массиву начиная со 2-го элемента
	{
		if (c1 < a[i - 1])                        // ищем место где должно стоять первое число
		{                                         // если место находится мы прерываем поиск
			ic = i;
			break;
		}
		else                                      // если чисел больше c1 в массиве нету, с1 должна стоять в начале
		{
			ic = 0;
		}
	}
	for (int i = n; i >= ic; i--)                 // проходим по массиву и сдвигаем все элементы 
	{                                             // которые стоят правее места для числа
		a[i] = a[i - 1];
	}
	a[ic] = c1;                                   // затем ставим первое число на его место
	a = (int*)realloc(a, (n + 2) * sizeof(int));        // увеличиваем место выделенное под массив
	for (int i = 1; i < n + 1; i++)                     // в цикле проходим по увеличенному массиву начиная со 2-го элемента
	{
		if (c2 < a[i - 1])                              // ищем место где должно стоять второе число
		{                                               // если место находится мы прерываем поиск
			ic = i;
			break;
		}
		else                                            // если чисел больше c2 в массиве нету, с2 должна стоять в начале
		{
			ic = 0;
		}
	}
	for (int i = n + 1; i >= ic; i--)                   // проходим по массиву и сдвигаем все элементы 
	{                                                   // которые стоят правее места для числа
		a[i] = a[i - 1];
	}
	a[ic] = c2;                                         // затем ставим первое число на его место
	printf("\n c= ");
	for (int i = 0; i < n + 2; i++)                     // выводим увеличенный упорядоченный массив
	{
		printf(" %d ", a[i]);
	}
	free(a);                                            // освобождаем память выделенную под массив
	_getch();
	return 0;
}



//	задача номер 5
//	
//	Задана матрица целых чисел N х N, 
//	найти все номера столбцов, элементы которых упорядочены по возрастанию.


#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<conio.h>
#include<locale.h>                                


int main()
{
	srand((unsigned)time(NULL));
	setlocale(LC_ALL, "rus");
	int n;
	printf("Введите число N\n");
	scanf("%d", &n);

	int **a = new int*[n];         // объявление массива

	for (int i = 0; i < n; i++)
	{                              // выделение памяти под массив
		a[i] = new int[n];
	}

	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)         // заполняем массив рандомными числами от 1 до 100
		{									// и выводим его
			a[i][j] = rand() % 100 + 1;
			printf(" [%d]  ", a[i][j]);
		}
		printf("\n");
	}

	printf("\n");
	printf("\n");
	int t=0;       // переменная которая считает кол-во упорядоченных столбцов
	int k;         // цепочка упорядоченных элементов
	int kmax;      // максимальная цепочка упорядоченных элементо
	for (int j = 0; j < n; ++j) // проходим по массиву начиная со столбцов
	{
		k = 1;    // задаём минимальную цепочку 1 т.к 1 элемент точно есть
		kmax = 1; // задаём максимальную цепочку 1 т.к 1 элемент точно есть и пока это 100% известная максимальная длинна
		for (int i = 0; i < n - 1; ++i)    // идем по строке
		{
			if (a[i + 1][j] >= a[i][j])    // если два последующих элемента столбца упорядоченный
			{                              // увеличиваем цепочку
				k++; 
			}
			else 
			{
				k = 1;                      // если последующие элементы неупорядоченны, сбрасываем цепочку
			}
			if (k > kmax)                   // если переменная цепочка больше максимальной переприсваиваем её в kmax
			{
				kmax = k; 
			}
		}
		if (kmax == n)                  // сравниваем после прохода по столбцу
		{                               // если есть цепочка равная длинне столбца то выводим номер столбца
			t++;                        // и добавляем в счетчик столбцов единицу
			printf("Упорядоченный столбец [%d]\n", j+1); //выводим j+1 (хотя 1 столбец = 0 для удобства)
		}
	}
	if (t == 0)                          // если нет упорядоченных столбцов сообщаем об этом
	{
		printf("Упорядоченных столбцов нет");
	}


	free(a);   // освобождаем память
	_getch();
	return 0;
}


//	задача номер 6
//	
//	6. Даны два положительных числа  А и В и последовательность чисел   
//	С1, С2, ... ,СМ, где  М = 100. Найти все числа Сi, чтобы А, В, Ci, 
//	были  длинами сторон одного равнобедренного треугольника.


#define _CRT_SECURE_NO_WARNINGS // для исправления ошибки со scanf_s

#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<conio.h>
#include<locale.h>

#define M 100   //по условию

int main()
{
	srand((unsigned)time(NULL));        // srand чтобы при каждом запуске задавались разные числа
	setlocale(LC_ALL, "rus");           // подключение русского языка  
	int c[M];
	int a, b;
	printf("Введите A и B ");
	scanf("%d %d", &a, &b);
	for (int i = 0; i < M; i++)       // по условию задачи массив состоит из 31 элемента из диапозона [-20;20]
	{
		c[i] = rand() % 100+1;      // случайно задается массив и выводится на экран
		printf("%d ", c[i]);
	}
	printf("\n");
	for (int i = 0; i < M; i++)    
	{
		
		if (a == c[i] || b == c[i])    //Проверяем две стороны на равенсто
		{
		
		printf("Равнобедренный треугольник (%d,%d,%d)\n", a, b, c[i]); //выводим найденный треугольник
		
		}
		
	}
	printf("\n");
	_getch();
	return 0;
}





//	задача номер 7
//	
//	По заданной матрице NxN, начиная с центра, 
//	обойти по спирали все ее элементы, 
//	распечатывая их в порядке обхода.

#define _CRT_SECURE_NO_WARNINGS // для исправления ошибки со scanf_s

#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<conio.h>
#include<locale.h>

int main()
{
	srand((unsigned)time(NULL));
	setlocale(LC_ALL, "rus");
	int N;
	printf("Введите число N\n");
	scanf("%d", &N);

	int **a = new int*[N];         // объявление массива

	for (int i = 0; i < N; i++)
	{                              // выделение памяти под массив
		a[i] = new int[N];
	}

	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < N; j++)         // заполняем массив рандомными числами от 1 до 100
		{									
			a[i][j] = rand() % 100 + 1;
		}
	}
	printf("\n");
	
		for (int i = 0; i < N; i = i + 1) {
	
			for (int j = 0; j < N; j = j + 1) {
	
				a[i][j] = rand() % 10 + 2;            //Печать массива по спирали
	
				printf("%3.d ", a[i][j]);
	
			}
	
			printf("\n");
	
		}
		printf("\n");
		
		int i, j, n, fWall = N - 1, nWall = 0; // fWall и nWall - нужны для ориентирования внутри массива
		i = 0; j = 0;						   //fWall - отступ до дальней стенки, nWall - отступ от ближней
	
		for (n = 0; n < N*N; n++) //Повторяется N*N раз.
	
		{
			printf("%d ", a[i][j]); //Печатаем элемент
	
			if ((i == (nWall + 1)) && (j == nWall)) { fWall--; nWall++; } // переход на внутреннюю спираль
	
			if ((j == fWall) && (i < fWall)) { i++; continue; } //Движение по спирали вниз
	
			if ((j < fWall) && (i == nWall)) { j++; continue; } //Движение по спирали Вправо
	
			if ((i == fWall) && (j > nWall)) { j--; continue; } //Движение по спирали Влевo
	
			if ((j == nWall) && (i > nWall)) { i--; continue; } //Движение по спирали Вверх
	
		}
	
	printf("\n");
	_getch();
	return 0;
}
